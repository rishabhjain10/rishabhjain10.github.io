{"default_url":null,"content":{"state":0,"taskInstructions":null,"references":[],"isTaskInstructionsVisible":true,"isCommentMandatory":false,"fields":[],"masterFinding":{"id":707,"exploitInstructions":"","verificationInstructions":"<h3><b>Verification Instructions:</b></h3><br><b><red>Be sure to use Firefox when validating CSRF</red></b>, Chrome will automatically set cookies' SameSite value to Lax which prevents cookies from being sent cross-domain on certain requests.<br><br>Follow these steps to verify CSRF:<br><ol><li>Choose some application functionality that changes data in the application, such as user profile update, that does not appear to contain CSRF protection</li><br><li>Send a valid request to the application</li><br><li>Based on the valid request, use Burp Generate CSRF PoC to create an HTML page that sends a CSRF payload to the application</li><br><li>While authenticated, open the CSRF PoC in a separate tab / window and submit the request to application to determine whether the application is susceptible to CSRF attacks.</li><br></ol><br>It is possible that the application has a static anti-CSRF token; by following the instructions above it appears that CSRF works but it is not really exploitable. Report <b>Cross-Site Request Forgery - Weak Token</b> instead stating that the application uses a static CSRF token.<br><br>If the application uses ViewState, try to determine if the ViewState value contains any session information. ViewState is not considered a strong anti-CSRF token by itself.<br><br><h3><b>Reporting Requirements:</b></h3><br><ol><li>Show the initial application state</li><br><li>Show the CSRF PoC HTML page</li><br><li>Show a browser tab with the CSRF PoC open</li><br><li>Show the application page from step 1 that displays data which was modified via the CSRF attack</li><br></ol><br><b>Note for ASP.NET applications:</b><br>The application uses VIEWSTATE which makes exploitation of cross-site request forgery harder. However, VIEWSTATE is not considered a valid anti-CSRF token unless it contains session information and thus cannot be replayed across multiple session. For information how to secure VIEWSTATE, see https://msdn.microsoft.com/en-us/library/ms178199(v=vs.85).aspx<br><br><b>Note for GraphQL applications:</b><br>Try to use some GraphQL-specific techniques to get CSRF. This mainly involves turning the traditional GraphQL POST request to a GET request or different format. See the following: <br><ul><li>https://outline.netspi.com/doc/graphql-testing-procedure-GRYBKabmWM&#35;h-graphql-csrf</li><br></ul><br>","remediationInstructions":"The following recommendations will help reduce the risk of cross-site request forgery attacks when used in addition to session cookies:<br><ul><li>Check the Referer header to ensure that the request originates from the same web site. It is possible to forge the Referer header, so validating the Referrer header should not be used as the sole measure to prevent CSRF. However, checking the Referer header does add a layer of security to the application. It should be noted that some firewalls or browser settings remove the Referer header, which could lead to a denial of service for legitimate users.</li><br><li>Use tokenizing. Tokenizing is a concept of adding a random, per-request token in the HTTP response that is sent from the server to the client. The client parses the response and extracts the token from it. With the next request, the client sends the token back to the server. The server accepts the request only if the token is the same as the token in the last response.</li><br></ul><br>","name":"Cross-Site Request Forgery","sourceId":"GID:3297","severity":"Medium","businessImpact":"Successful exploitation of cross-site request forgery allows an attacker to take action within the permissions context of the affected user within an application, potentially compromising the confidentiality, integrity, and availability of that user's information. Sending malicious requests on behalf of an affected user can make it difficult to discover the true origin of the attack.","description":"Cross-site request forgery (CSRF) is an attack where a user is forced to unknowingly send a request to a web application in which the user is currently authenticated. This can be accomplished by having the target user click a malicious URL or visit a web site that sends the request. The request is executed on the target web server as if the user had sent it on purpose, and it can be used to execute any application functions that the user is normally allowed to perform. Depending on the nature of the application and the vulnerability, CSRF can be used to take actions such as transferring funds or resetting the user's password.<br>The basis for cross-site request forgery attacks is that session cookies used to identify an authenticated user are automatically sent to the target server along with all requests from the target user. CSRF attacks do not require hijacking the target user's session since the malicious requests generated by the attacker are authenticated requests that originate from the target user. CSRF attacks exploit the server's implicit trust in the identity of the user sending the request.<br>"}}}